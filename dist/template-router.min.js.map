{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///template-router.min.js","webpack:///webpack/bootstrap ae8e1df76b1f2dccc80c","webpack:///./src/index.ts","webpack:///./node_modules/page/index.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/path-to-regexp/index.js","webpack:///./node_modules/isarray/index.js"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","__esModule","undefined","default","headers","common","Accept","adapter","transformRequest","transformResponse","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","getLoadPageFunction","pageInfo","ctx","next","__awaiter","callMiddleware","middleware","newCtx","Array","isArray","forEach","singleMiddleware","tempCtx","beforeFetchMiddlewareInfo","data","beforeRenderMiddlewareInfo","html","afterRenderMiddlewareInfo","__generator","_a","label","querySelector","template","endpoint","middlewareInfo","beforeFetch","cancel","fetch","then","response","json","sent","beforeRender","afterRender","document","innerHTML","save","value","__WEBPACK_IMPORTED_MODULE_0_page__","__WEBPACK_IMPORTED_MODULE_0_page___default","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","e","rejected","result","done","apply","body","verb","v","op","f","TypeError","_","y","t","ops","pop","trys","length","push","g","throw","return","Symbol","iterator","TemplateRouter","routeInfos","routeInfo","route","page","a","process","path","fn","Route","arguments","callbacks","start","unhandled","handled","current","hashbang","base","location","hash","replace","pathname","search","canonicalPath","stop","href","decodeURLEncodedURIComponent","val","decodeURLComponents","decodeURIComponent","Context","state","indexOf","title","querystring","slice","params","parts","split","options","method","regexp","pathtoRegexp","keys","onclick","which","metaKey","ctrlKey","shiftKey","defaultPrevented","el","target","nodeName","parentNode","hasAttribute","getAttribute","link","sameOrigin","match","orig","substr","preventDefault","show","window","event","button","origin","protocol","hostname","port","running","prevContext","clickEvent","ontouchstart","history","dispatch","exits","len","popstate","addEventListener","onpopstate","click","url","removeEventListener","pushState","back","setTimeout","redirect","from","to","init","nextExit","j","nextEnter","prev","exit","replaceState","qsIndex","exec","key","loaded","readyState","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","timeout","run","Item","array","noop","nextTick","args","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","parse","str","res","tokens","index","PATH_REGEXP","escaped","offset","prefix","capture","group","suffix","asterisk","repeat","optional","delimiter","pattern","escapeGroup","compile","tokensToFunction","matches","RegExp","obj","token","segment","isarray","encodeURIComponent","test","escapeString","attachKeys","re","flags","sensitive","regexpToRegexp","groups","source","arrayToRegexp","pathToRegexp","join","stringToRegexp","tokensToRegExp","strict","end","lastToken","endsWithSlash","arr","toString"],"mappings":"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","file":"template-router.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"TemplateRouter\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"TemplateRouter\"] = factory();\n\telse\n\t\troot[\"TemplateRouter\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"TemplateRouter\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"TemplateRouter\"] = factory();\n\telse\n\t\troot[\"TemplateRouter\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\t(function (module) {\n/******/ \t\t  if (module.exports\n/******/ \t\t    && !module.exports.__esModule\n/******/ \t\t    && module.exports.default === undefined\n/******/ \t\t  ) {\n/******/ \t\t    if (module.exports.headers\n/******/ \t\t      && module.exports.headers.common\n/******/ \t\t      && module.exports.headers.common.Accept\n/******/ \t\t      && module.exports.adapter\n/******/ \t\t      && module.exports.transformRequest\n/******/ \t\t      && module.exports.transformResponse\n/******/ \t\t    ) {\n/******/ \t\t      return;\n/******/ \t\t    }\n/******/ \t\t    module.exports.default = module.exports;\n/******/ \t\t  }\n/******/ \t\t})(module);\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_page__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_page___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_page__);\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\n\r\nvar TemplateRouter = function TemplateRouter(routeInfos) {\r\n    if (!Array.isArray(routeInfos) && typeof routeInfos === \"object\") {\r\n        __WEBPACK_IMPORTED_MODULE_0_page___default()(routeInfos.route, getLoadPageFunction(routeInfos));\r\n    }\r\n    else if (Array.isArray(routeInfos)) {\r\n        routeInfos.forEach(function (routeInfo) { return __WEBPACK_IMPORTED_MODULE_0_page___default()(routeInfo.route, getLoadPageFunction(routeInfo)); });\r\n    }\r\n};\r\nfunction getLoadPageFunction(pageInfo) {\r\n    return function (ctx, next) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            function callMiddleware(middleware) {\r\n                var newCtx = ctx;\r\n                if (middleware) {\r\n                    if (Array.isArray(middleware)) {\r\n                        middleware.forEach(function (singleMiddleware) {\r\n                            var tempCtx = singleMiddleware(newCtx);\r\n                            if (tempCtx)\r\n                                newCtx = tempCtx;\r\n                        });\r\n                    }\r\n                    else if (typeof middleware === \"function\") {\r\n                        var tempCtx = middleware(newCtx);\r\n                        if (tempCtx)\r\n                            newCtx = tempCtx;\r\n                    }\r\n                }\r\n                return newCtx;\r\n            }\r\n            var newCtx, beforeFetchMiddlewareInfo, data, beforeRenderMiddlewareInfo, html, afterRenderMiddlewareInfo;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        beforeFetchMiddlewareInfo = {\r\n                            querySelector: pageInfo.querySelector || \"body\",\r\n                            template: pageInfo.template,\r\n                            endpoint: pageInfo.endpoint,\r\n                        };\r\n                        ctx.middlewareInfo = beforeFetchMiddlewareInfo;\r\n                        newCtx = callMiddleware(pageInfo.beforeFetch);\r\n                        if (newCtx) {\r\n                            ctx = newCtx;\r\n                            if (newCtx.middlewareInfo.cancel)\r\n                                next();\r\n                        }\r\n                        return [4 /*yield*/, fetch(ctx.middlewareInfo.endpoint).then(function (response) { return response.json(); })];\r\n                    case 1:\r\n                        data = _a.sent();\r\n                        beforeRenderMiddlewareInfo = {\r\n                            querySelector: ctx.middlewareInfo.querySelector,\r\n                            template: ctx.middlewareInfo.template,\r\n                            data: data\r\n                        };\r\n                        ctx.middlewareInfo = beforeRenderMiddlewareInfo;\r\n                        newCtx = callMiddleware(pageInfo.beforeRender);\r\n                        if (newCtx) {\r\n                            ctx = newCtx;\r\n                            if (newCtx.middlewareInfo.cancel)\r\n                                next();\r\n                        }\r\n                        html = ctx.middlewareInfo.template(ctx.middlewareInfo.data);\r\n                        afterRenderMiddlewareInfo = {\r\n                            querySelector: ctx.middlewareInfo.querySelector,\r\n                            html: html\r\n                        };\r\n                        ctx.middlewareInfo = afterRenderMiddlewareInfo;\r\n                        newCtx = callMiddleware(pageInfo.afterRender);\r\n                        if (newCtx) {\r\n                            ctx = newCtx;\r\n                            if (newCtx.middlewareInfo.cancel)\r\n                                next();\r\n                        }\r\n                        document.querySelector(ctx.middlewareInfo.querySelector).innerHTML = html;\r\n                        ctx.save();\r\n                        next();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n}\r\nTemplateRouter.page = __WEBPACK_IMPORTED_MODULE_0_page___default.a;\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (TemplateRouter);\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {  /* globals require, module */\n\n  \n\n  /**\n   * Module dependencies.\n   */\n\n  var pathtoRegexp = __webpack_require__(3);\n\n  /**\n   * Module exports.\n   */\n\n  module.exports = page;\n\n  /**\n   * Detect click event\n   */\n  var clickEvent = ('undefined' !== typeof document) && document.ontouchstart ? 'touchstart' : 'click';\n\n  /**\n   * To work properly with the URL\n   * history.location generated polyfill in https://github.com/devote/HTML5-History-API\n   */\n\n  var location = ('undefined' !== typeof window) && (window.history.location || window.location);\n\n  /**\n   * Perform initial dispatch.\n   */\n\n  var dispatch = true;\n\n\n  /**\n   * Decode URL components (query string, pathname, hash).\n   * Accommodates both regular percent encoding and x-www-form-urlencoded format.\n   */\n  var decodeURLComponents = true;\n\n  /**\n   * Base path.\n   */\n\n  var base = '';\n\n  /**\n   * Running flag.\n   */\n\n  var running;\n\n  /**\n   * HashBang option\n   */\n\n  var hashbang = false;\n\n  /**\n   * Previous context, for capturing\n   * page exit events.\n   */\n\n  var prevContext;\n\n  /**\n   * Register `path` with callback `fn()`,\n   * or route `path`, or redirection,\n   * or `page.start()`.\n   *\n   *   page(fn);\n   *   page('*', fn);\n   *   page('/user/:id', load, user);\n   *   page('/user/' + user.id, { some: 'thing' });\n   *   page('/user/' + user.id);\n   *   page('/from', '/to')\n   *   page();\n   *\n   * @param {string|!Function|!Object} path\n   * @param {Function=} fn\n   * @api public\n   */\n\n  function page(path, fn) {\n    // <callback>\n    if ('function' === typeof path) {\n      return page('*', path);\n    }\n\n    // route <path> to <callback ...>\n    if ('function' === typeof fn) {\n      var route = new Route(/** @type {string} */ (path));\n      for (var i = 1; i < arguments.length; ++i) {\n        page.callbacks.push(route.middleware(arguments[i]));\n      }\n      // show <path> with [state]\n    } else if ('string' === typeof path) {\n      page['string' === typeof fn ? 'redirect' : 'show'](path, fn);\n      // start [options]\n    } else {\n      page.start(path);\n    }\n  }\n\n  /**\n   * Callback functions.\n   */\n\n  page.callbacks = [];\n  page.exits = [];\n\n  /**\n   * Current path being processed\n   * @type {string}\n   */\n  page.current = '';\n\n  /**\n   * Number of pages navigated to.\n   * @type {number}\n   *\n   *     page.len == 0;\n   *     page('/login');\n   *     page.len == 1;\n   */\n\n  page.len = 0;\n\n  /**\n   * Get or set basepath to `path`.\n   *\n   * @param {string} path\n   * @api public\n   */\n\n  page.base = function(path) {\n    if (0 === arguments.length) return base;\n    base = path;\n  };\n\n  /**\n   * Bind with the given `options`.\n   *\n   * Options:\n   *\n   *    - `click` bind to click events [true]\n   *    - `popstate` bind to popstate [true]\n   *    - `dispatch` perform initial dispatch [true]\n   *\n   * @param {Object} options\n   * @api public\n   */\n\n  page.start = function(options) {\n    options = options || {};\n    if (running) return;\n    running = true;\n    if (false === options.dispatch) dispatch = false;\n    if (false === options.decodeURLComponents) decodeURLComponents = false;\n    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);\n    if (false !== options.click) {\n      document.addEventListener(clickEvent, onclick, false);\n    }\n    if (true === options.hashbang) hashbang = true;\n    if (!dispatch) return;\n    var url = (hashbang && ~location.hash.indexOf('#!')) ? location.hash.substr(2) + location.search : location.pathname + location.search + location.hash;\n    page.replace(url, null, true, dispatch);\n  };\n\n  /**\n   * Unbind click and popstate event handlers.\n   *\n   * @api public\n   */\n\n  page.stop = function() {\n    if (!running) return;\n    page.current = '';\n    page.len = 0;\n    running = false;\n    document.removeEventListener(clickEvent, onclick, false);\n    window.removeEventListener('popstate', onpopstate, false);\n  };\n\n  /**\n   * Show `path` with optional `state` object.\n   *\n   * @param {string} path\n   * @param {Object=} state\n   * @param {boolean=} dispatch\n   * @param {boolean=} push\n   * @return {!Context}\n   * @api public\n   */\n\n  page.show = function(path, state, dispatch, push) {\n    var ctx = new Context(path, state);\n    page.current = ctx.path;\n    if (false !== dispatch) page.dispatch(ctx);\n    if (false !== ctx.handled && false !== push) ctx.pushState();\n    return ctx;\n  };\n\n  /**\n   * Goes back in the history\n   * Back should always let the current route push state and then go back.\n   *\n   * @param {string} path - fallback path to go back if no more history exists, if undefined defaults to page.base\n   * @param {Object=} state\n   * @api public\n   */\n\n  page.back = function(path, state) {\n    if (page.len > 0) {\n      // this may need more testing to see if all browsers\n      // wait for the next tick to go back in history\n      history.back();\n      page.len--;\n    } else if (path) {\n      setTimeout(function() {\n        page.show(path, state);\n      });\n    }else{\n      setTimeout(function() {\n        page.show(base, state);\n      });\n    }\n  };\n\n\n  /**\n   * Register route to redirect from one path to other\n   * or just redirect to another route\n   *\n   * @param {string} from - if param 'to' is undefined redirects to 'from'\n   * @param {string=} to\n   * @api public\n   */\n  page.redirect = function(from, to) {\n    // Define route from a path to another\n    if ('string' === typeof from && 'string' === typeof to) {\n      page(from, function(e) {\n        setTimeout(function() {\n          page.replace(/** @type {!string} */ (to));\n        }, 0);\n      });\n    }\n\n    // Wait for the push state and replace it with another\n    if ('string' === typeof from && 'undefined' === typeof to) {\n      setTimeout(function() {\n        page.replace(from);\n      }, 0);\n    }\n  };\n\n  /**\n   * Replace `path` with optional `state` object.\n   *\n   * @param {string} path\n   * @param {Object=} state\n   * @param {boolean=} init\n   * @param {boolean=} dispatch\n   * @return {!Context}\n   * @api public\n   */\n\n\n  page.replace = function(path, state, init, dispatch) {\n    var ctx = new Context(path, state);\n    page.current = ctx.path;\n    ctx.init = init;\n    ctx.save(); // save before dispatching, which may redirect\n    if (false !== dispatch) page.dispatch(ctx);\n    return ctx;\n  };\n\n  /**\n   * Dispatch the given `ctx`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n  page.dispatch = function(ctx) {\n    var prev = prevContext,\n      i = 0,\n      j = 0;\n\n    prevContext = ctx;\n\n    function nextExit() {\n      var fn = page.exits[j++];\n      if (!fn) return nextEnter();\n      fn(prev, nextExit);\n    }\n\n    function nextEnter() {\n      var fn = page.callbacks[i++];\n\n      if (ctx.path !== page.current) {\n        ctx.handled = false;\n        return;\n      }\n      if (!fn) return unhandled(ctx);\n      fn(ctx, nextEnter);\n    }\n\n    if (prev) {\n      nextExit();\n    } else {\n      nextEnter();\n    }\n  };\n\n  /**\n   * Unhandled `ctx`. When it's not the initial\n   * popstate then redirect. If you wish to handle\n   * 404s on your own use `page('*', callback)`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n  function unhandled(ctx) {\n    if (ctx.handled) return;\n    var current;\n\n    if (hashbang) {\n      current = base + location.hash.replace('#!', '');\n    } else {\n      current = location.pathname + location.search;\n    }\n\n    if (current === ctx.canonicalPath) return;\n    page.stop();\n    ctx.handled = false;\n    location.href = ctx.canonicalPath;\n  }\n\n  /**\n   * Register an exit route on `path` with\n   * callback `fn()`, which will be called\n   * on the previous context when a new\n   * page is visited.\n   */\n  page.exit = function(path, fn) {\n    if (typeof path === 'function') {\n      return page.exit('*', path);\n    }\n\n    var route = new Route(path);\n    for (var i = 1; i < arguments.length; ++i) {\n      page.exits.push(route.middleware(arguments[i]));\n    }\n  };\n\n  /**\n   * Remove URL encoding from the given `str`.\n   * Accommodates whitespace in both x-www-form-urlencoded\n   * and regular percent-encoded form.\n   *\n   * @param {string} val - URL component to decode\n   */\n  function decodeURLEncodedURIComponent(val) {\n    if (typeof val !== 'string') { return val; }\n    return decodeURLComponents ? decodeURIComponent(val.replace(/\\+/g, ' ')) : val;\n  }\n\n  /**\n   * Initialize a new \"request\" `Context`\n   * with the given `path` and optional initial `state`.\n   *\n   * @constructor\n   * @param {string} path\n   * @param {Object=} state\n   * @api public\n   */\n\n  function Context(path, state) {\n    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + (hashbang ? '#!' : '') + path;\n    var i = path.indexOf('?');\n\n    this.canonicalPath = path;\n    this.path = path.replace(base, '') || '/';\n    if (hashbang) this.path = this.path.replace('#!', '') || '/';\n\n    this.title = document.title;\n    this.state = state || {};\n    this.state.path = path;\n    this.querystring = ~i ? decodeURLEncodedURIComponent(path.slice(i + 1)) : '';\n    this.pathname = decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);\n    this.params = {};\n\n    // fragment\n    this.hash = '';\n    if (!hashbang) {\n      if (!~this.path.indexOf('#')) return;\n      var parts = this.path.split('#');\n      this.path = parts[0];\n      this.hash = decodeURLEncodedURIComponent(parts[1]) || '';\n      this.querystring = this.querystring.split('#')[0];\n    }\n  }\n\n  /**\n   * Expose `Context`.\n   */\n\n  page.Context = Context;\n\n  /**\n   * Push state.\n   *\n   * @api private\n   */\n\n  Context.prototype.pushState = function() {\n    page.len++;\n    history.pushState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n  };\n\n  /**\n   * Save the context state.\n   *\n   * @api public\n   */\n\n  Context.prototype.save = function() {\n    history.replaceState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n  };\n\n  /**\n   * Initialize `Route` with the given HTTP `path`,\n   * and an array of `callbacks` and `options`.\n   *\n   * Options:\n   *\n   *   - `sensitive`    enable case-sensitive routes\n   *   - `strict`       enable strict matching for trailing slashes\n   *\n   * @constructor\n   * @param {string} path\n   * @param {Object=} options\n   * @api private\n   */\n\n  function Route(path, options) {\n    options = options || {};\n    this.path = (path === '*') ? '(.*)' : path;\n    this.method = 'GET';\n    this.regexp = pathtoRegexp(this.path,\n      this.keys = [],\n      options);\n  }\n\n  /**\n   * Expose `Route`.\n   */\n\n  page.Route = Route;\n\n  /**\n   * Return route middleware with\n   * the given callback `fn()`.\n   *\n   * @param {Function} fn\n   * @return {Function}\n   * @api public\n   */\n\n  Route.prototype.middleware = function(fn) {\n    var self = this;\n    return function(ctx, next) {\n      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);\n      next();\n    };\n  };\n\n  /**\n   * Check if this route matches `path`, if so\n   * populate `params`.\n   *\n   * @param {string} path\n   * @param {Object} params\n   * @return {boolean}\n   * @api private\n   */\n\n  Route.prototype.match = function(path, params) {\n    var keys = this.keys,\n      qsIndex = path.indexOf('?'),\n      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,\n      m = this.regexp.exec(decodeURIComponent(pathname));\n\n    if (!m) return false;\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      var key = keys[i - 1];\n      var val = decodeURLEncodedURIComponent(m[i]);\n      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {\n        params[key.name] = val;\n      }\n    }\n\n    return true;\n  };\n\n\n  /**\n   * Handle \"populate\" events.\n   */\n\n  var onpopstate = (function () {\n    var loaded = false;\n    if ('undefined' === typeof window) {\n      return;\n    }\n    if (document.readyState === 'complete') {\n      loaded = true;\n    } else {\n      window.addEventListener('load', function() {\n        setTimeout(function() {\n          loaded = true;\n        }, 0);\n      });\n    }\n    return function onpopstate(e) {\n      if (!loaded) return;\n      if (e.state) {\n        var path = e.state.path;\n        page.replace(path, e.state);\n      } else {\n        page.show(location.pathname + location.hash, undefined, undefined, false);\n      }\n    };\n  })();\n  /**\n   * Handle \"click\" events.\n   */\n\n  function onclick(e) {\n\n    if (1 !== which(e)) return;\n\n    if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n    if (e.defaultPrevented) return;\n\n\n\n    // ensure link\n    // use shadow dom when available\n    var el = e.path ? e.path[0] : e.target;\n    while (el && 'A' !== el.nodeName) el = el.parentNode;\n    if (!el || 'A' !== el.nodeName) return;\n\n\n\n    // Ignore if tag has\n    // 1. \"download\" attribute\n    // 2. rel=\"external\" attribute\n    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;\n\n    // ensure non-hash for the same path\n    var link = el.getAttribute('href');\n    if (!hashbang && el.pathname === location.pathname && (el.hash || '#' === link)) return;\n\n\n\n    // Check for mailto: in the href\n    if (link && link.indexOf('mailto:') > -1) return;\n\n    // check target\n    if (el.target) return;\n\n    // x-origin\n    if (!sameOrigin(el.href)) return;\n\n\n\n    // rebuild path\n    var path = el.pathname + el.search + (el.hash || '');\n\n    // strip leading \"/[drive letter]:\" on NW.js on Windows\n    if (typeof process !== 'undefined' && path.match(/^\\/[a-zA-Z]:\\//)) {\n      path = path.replace(/^\\/[a-zA-Z]:\\//, '/');\n    }\n\n    // same page\n    var orig = path;\n\n    if (path.indexOf(base) === 0) {\n      path = path.substr(base.length);\n    }\n\n    if (hashbang) path = path.replace('#!', '');\n\n    if (base && orig === path) return;\n\n    e.preventDefault();\n    page.show(orig);\n  }\n\n  /**\n   * Event button.\n   */\n\n  function which(e) {\n    e = e || window.event;\n    return null === e.which ? e.button : e.which;\n  }\n\n  /**\n   * Check if `href` is the same origin.\n   */\n\n  function sameOrigin(href) {\n    var origin = location.protocol + '//' + location.hostname;\n    if (location.port) origin += ':' + location.port;\n    return (href && (0 === href.indexOf(origin)));\n  }\n\n  page.sameOrigin = sameOrigin;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isarray = __webpack_require__(4)\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {String} str\n * @return {Array}\n */\nfunction parse (str) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var suffix = res[6]\n    var asterisk = res[7]\n\n    var repeat = suffix === '+' || suffix === '*'\n    var optional = suffix === '?' || suffix === '*'\n    var delimiter = prefix || '/'\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: escapeGroup(pattern)\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {String}   str\n * @return {Function}\n */\nfunction compile (str) {\n  return tokensToFunction(parse(str))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^' + tokens[i].pattern + '$')\n    }\n  }\n\n  return function (obj) {\n    var path = ''\n    var data = obj || {}\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received \"' + value + '\"')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encodeURIComponent(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = encodeURIComponent(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {String} str\n * @return {String}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {String} group\n * @return {String}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {RegExp} re\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {String}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {RegExp} path\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {Array}  path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {String} path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  var tokens = parse(path)\n  var re = tokensToRegExp(tokens, options)\n\n  // Attach keys back to the regexp.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] !== 'string') {\n      keys.push(tokens[i])\n    }\n  }\n\n  return attachKeys(re, keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {Array}  tokens\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction tokensToRegExp (tokens, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n  var lastToken = tokens[tokens.length - 1]\n  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken)\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = token.pattern\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (prefix) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)'\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(String|RegExp|Array)} path\n * @param  {Array}                 [keys]\n * @param  {Object}                [options]\n * @return {RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || []\n\n  if (!isarray(keys)) {\n    options = keys\n    keys = []\n  } else if (!options) {\n    options = {}\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys, options)\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(path, keys, options)\n  }\n\n  return stringToRegexp(path, keys, options)\n}\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n/***/ })\n/******/ ])[\"default\"];\n});\n\n\n// WEBPACK FOOTER //\n// template-router.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\t(function (module) {\n \t\t  if (module.exports\n \t\t    && !module.exports.__esModule\n \t\t    && module.exports.default === undefined\n \t\t  ) {\n \t\t    if (module.exports.headers\n \t\t      && module.exports.headers.common\n \t\t      && module.exports.headers.common.Accept\n \t\t      && module.exports.adapter\n \t\t      && module.exports.transformRequest\n \t\t      && module.exports.transformResponse\n \t\t    ) {\n \t\t      return;\n \t\t    }\n \t\t    module.exports.default = module.exports;\n \t\t  }\n \t\t})(module);\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ae8e1df76b1f2dccc80c","import page from \"page\";\r\n\r\nconst TemplateRouter: ITemplateRouter = function TemplateRouter(routeInfos: IRouteInfo | Array<IRouteInfo>) {\r\n    if (!Array.isArray(routeInfos) && typeof routeInfos === \"object\") {\r\n        page(routeInfos.route, getLoadPageFunction(routeInfos));\r\n    } else if (Array.isArray(routeInfos)) {\r\n        routeInfos.forEach(routeInfo => page(routeInfo.route, getLoadPageFunction(routeInfo)));\r\n    }\r\n};\r\n\r\nfunction getLoadPageFunction(pageInfo: IPageInfo): PageJS.Callback {\r\n    return async function (ctx: PageJS.Context, next: () => any): Promise<void> {\r\n        let newCtx: PageJS.Context;\r\n\r\n        const beforeFetchMiddlewareInfo: IBeforeFetchMiddlewareInfo = {\r\n            querySelector: pageInfo.querySelector || \"body\",\r\n            template: pageInfo.template,\r\n            endpoint: pageInfo.endpoint,\r\n        };\r\n        ctx.middlewareInfo = beforeFetchMiddlewareInfo;\r\n        newCtx = callMiddleware(pageInfo.beforeFetch);\r\n        if (newCtx) {\r\n            ctx = newCtx;\r\n            if (newCtx.middlewareInfo.cancel) next();\r\n        }\r\n\r\n        const data = await fetch(ctx.middlewareInfo.endpoint).then(response => response.json());\r\n\r\n        const beforeRenderMiddlewareInfo: IBeforeRenderMiddlewareInfo = {\r\n            querySelector: ctx.middlewareInfo.querySelector,\r\n            template: ctx.middlewareInfo.template,\r\n            data\r\n        };\r\n        ctx.middlewareInfo = beforeRenderMiddlewareInfo;\r\n        newCtx = callMiddleware(pageInfo.beforeRender);\r\n        if (newCtx) {\r\n            ctx = newCtx;\r\n            if (newCtx.middlewareInfo.cancel) next();\r\n        }\r\n\r\n        const html: string = ctx.middlewareInfo.template(ctx.middlewareInfo.data);\r\n\r\n        const afterRenderMiddlewareInfo: IAfterRenderMiddlewareInfo = {\r\n            querySelector: ctx.middlewareInfo.querySelector,\r\n            html\r\n        };\r\n        ctx.middlewareInfo = afterRenderMiddlewareInfo;\r\n        newCtx = callMiddleware(pageInfo.afterRender);\r\n        if (newCtx) {\r\n            ctx = newCtx;\r\n            if (newCtx.middlewareInfo.cancel) next();\r\n        }\r\n\r\n        document.querySelector(ctx.middlewareInfo.querySelector).innerHTML = html;\r\n\r\n        ctx.save();\r\n        next();\r\n\r\n        function callMiddleware(middleware: Middleware): PageJS.Context {\r\n            let newCtx: PageJS.Context = ctx;\r\n\r\n            if (middleware) {\r\n                if (Array.isArray(middleware)) {\r\n                    middleware.forEach(singleMiddleware => {\r\n                        const tempCtx: PageJS.Context = singleMiddleware(newCtx);\r\n                        if (tempCtx) newCtx = tempCtx;\r\n                    });\r\n                } else if (typeof middleware === \"function\") {\r\n                    const tempCtx: PageJS.Context = middleware(newCtx);\r\n                    if (tempCtx) newCtx = tempCtx;\r\n                }\r\n            }\r\n\r\n            return newCtx;\r\n        }\r\n    };\r\n}\r\n\r\ninterface ITemplateRouter {\r\n    (routeInfos: IRouteInfo | Array<IRouteInfo>);\r\n    page?: PageJS.Static;\r\n}\r\n\r\ntype CtxFunction = (ctx: PageJS.Context) => PageJS.Context;\r\ntype Middleware = CtxFunction | Array<CtxFunction>;\r\n\r\ninterface IBaseMiddlewareInfo {\r\n    querySelector: string;\r\n    cancel?: boolean;\r\n}\r\n\r\ninterface ITemplateMixin {\r\n    template: (data: object) => string;\r\n}\r\n\r\ntype IBeforeFetchMiddlewareInfo = IBaseMiddlewareInfo & ITemplateMixin & {\r\n    endpoint: string;\r\n}\r\n\r\ntype IBeforeRenderMiddlewareInfo = IBaseMiddlewareInfo & ITemplateMixin & {\r\n    data: object;\r\n}\r\n\r\ntype IAfterRenderMiddlewareInfo = IBaseMiddlewareInfo & {\r\n    html: string;\r\n}\r\n\r\ninterface IPageInfo {\r\n    querySelector?: string;\r\n    template?: (data: object) => string;\r\n    endpoint?: string;\r\n    beforeFetch?: Middleware;\r\n    beforeRender?: Middleware;\r\n    afterRender?: Middleware;\r\n}\r\n\r\ninterface IRouteInfo extends IPageInfo {\r\n    route: string;\r\n}\r\n\r\nTemplateRouter.page = page;\r\n\r\nexport default TemplateRouter;\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","  /* globals require, module */\n\n  'use strict';\n\n  /**\n   * Module dependencies.\n   */\n\n  var pathtoRegexp = require('path-to-regexp');\n\n  /**\n   * Module exports.\n   */\n\n  module.exports = page;\n\n  /**\n   * Detect click event\n   */\n  var clickEvent = ('undefined' !== typeof document) && document.ontouchstart ? 'touchstart' : 'click';\n\n  /**\n   * To work properly with the URL\n   * history.location generated polyfill in https://github.com/devote/HTML5-History-API\n   */\n\n  var location = ('undefined' !== typeof window) && (window.history.location || window.location);\n\n  /**\n   * Perform initial dispatch.\n   */\n\n  var dispatch = true;\n\n\n  /**\n   * Decode URL components (query string, pathname, hash).\n   * Accommodates both regular percent encoding and x-www-form-urlencoded format.\n   */\n  var decodeURLComponents = true;\n\n  /**\n   * Base path.\n   */\n\n  var base = '';\n\n  /**\n   * Running flag.\n   */\n\n  var running;\n\n  /**\n   * HashBang option\n   */\n\n  var hashbang = false;\n\n  /**\n   * Previous context, for capturing\n   * page exit events.\n   */\n\n  var prevContext;\n\n  /**\n   * Register `path` with callback `fn()`,\n   * or route `path`, or redirection,\n   * or `page.start()`.\n   *\n   *   page(fn);\n   *   page('*', fn);\n   *   page('/user/:id', load, user);\n   *   page('/user/' + user.id, { some: 'thing' });\n   *   page('/user/' + user.id);\n   *   page('/from', '/to')\n   *   page();\n   *\n   * @param {string|!Function|!Object} path\n   * @param {Function=} fn\n   * @api public\n   */\n\n  function page(path, fn) {\n    // <callback>\n    if ('function' === typeof path) {\n      return page('*', path);\n    }\n\n    // route <path> to <callback ...>\n    if ('function' === typeof fn) {\n      var route = new Route(/** @type {string} */ (path));\n      for (var i = 1; i < arguments.length; ++i) {\n        page.callbacks.push(route.middleware(arguments[i]));\n      }\n      // show <path> with [state]\n    } else if ('string' === typeof path) {\n      page['string' === typeof fn ? 'redirect' : 'show'](path, fn);\n      // start [options]\n    } else {\n      page.start(path);\n    }\n  }\n\n  /**\n   * Callback functions.\n   */\n\n  page.callbacks = [];\n  page.exits = [];\n\n  /**\n   * Current path being processed\n   * @type {string}\n   */\n  page.current = '';\n\n  /**\n   * Number of pages navigated to.\n   * @type {number}\n   *\n   *     page.len == 0;\n   *     page('/login');\n   *     page.len == 1;\n   */\n\n  page.len = 0;\n\n  /**\n   * Get or set basepath to `path`.\n   *\n   * @param {string} path\n   * @api public\n   */\n\n  page.base = function(path) {\n    if (0 === arguments.length) return base;\n    base = path;\n  };\n\n  /**\n   * Bind with the given `options`.\n   *\n   * Options:\n   *\n   *    - `click` bind to click events [true]\n   *    - `popstate` bind to popstate [true]\n   *    - `dispatch` perform initial dispatch [true]\n   *\n   * @param {Object} options\n   * @api public\n   */\n\n  page.start = function(options) {\n    options = options || {};\n    if (running) return;\n    running = true;\n    if (false === options.dispatch) dispatch = false;\n    if (false === options.decodeURLComponents) decodeURLComponents = false;\n    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);\n    if (false !== options.click) {\n      document.addEventListener(clickEvent, onclick, false);\n    }\n    if (true === options.hashbang) hashbang = true;\n    if (!dispatch) return;\n    var url = (hashbang && ~location.hash.indexOf('#!')) ? location.hash.substr(2) + location.search : location.pathname + location.search + location.hash;\n    page.replace(url, null, true, dispatch);\n  };\n\n  /**\n   * Unbind click and popstate event handlers.\n   *\n   * @api public\n   */\n\n  page.stop = function() {\n    if (!running) return;\n    page.current = '';\n    page.len = 0;\n    running = false;\n    document.removeEventListener(clickEvent, onclick, false);\n    window.removeEventListener('popstate', onpopstate, false);\n  };\n\n  /**\n   * Show `path` with optional `state` object.\n   *\n   * @param {string} path\n   * @param {Object=} state\n   * @param {boolean=} dispatch\n   * @param {boolean=} push\n   * @return {!Context}\n   * @api public\n   */\n\n  page.show = function(path, state, dispatch, push) {\n    var ctx = new Context(path, state);\n    page.current = ctx.path;\n    if (false !== dispatch) page.dispatch(ctx);\n    if (false !== ctx.handled && false !== push) ctx.pushState();\n    return ctx;\n  };\n\n  /**\n   * Goes back in the history\n   * Back should always let the current route push state and then go back.\n   *\n   * @param {string} path - fallback path to go back if no more history exists, if undefined defaults to page.base\n   * @param {Object=} state\n   * @api public\n   */\n\n  page.back = function(path, state) {\n    if (page.len > 0) {\n      // this may need more testing to see if all browsers\n      // wait for the next tick to go back in history\n      history.back();\n      page.len--;\n    } else if (path) {\n      setTimeout(function() {\n        page.show(path, state);\n      });\n    }else{\n      setTimeout(function() {\n        page.show(base, state);\n      });\n    }\n  };\n\n\n  /**\n   * Register route to redirect from one path to other\n   * or just redirect to another route\n   *\n   * @param {string} from - if param 'to' is undefined redirects to 'from'\n   * @param {string=} to\n   * @api public\n   */\n  page.redirect = function(from, to) {\n    // Define route from a path to another\n    if ('string' === typeof from && 'string' === typeof to) {\n      page(from, function(e) {\n        setTimeout(function() {\n          page.replace(/** @type {!string} */ (to));\n        }, 0);\n      });\n    }\n\n    // Wait for the push state and replace it with another\n    if ('string' === typeof from && 'undefined' === typeof to) {\n      setTimeout(function() {\n        page.replace(from);\n      }, 0);\n    }\n  };\n\n  /**\n   * Replace `path` with optional `state` object.\n   *\n   * @param {string} path\n   * @param {Object=} state\n   * @param {boolean=} init\n   * @param {boolean=} dispatch\n   * @return {!Context}\n   * @api public\n   */\n\n\n  page.replace = function(path, state, init, dispatch) {\n    var ctx = new Context(path, state);\n    page.current = ctx.path;\n    ctx.init = init;\n    ctx.save(); // save before dispatching, which may redirect\n    if (false !== dispatch) page.dispatch(ctx);\n    return ctx;\n  };\n\n  /**\n   * Dispatch the given `ctx`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n  page.dispatch = function(ctx) {\n    var prev = prevContext,\n      i = 0,\n      j = 0;\n\n    prevContext = ctx;\n\n    function nextExit() {\n      var fn = page.exits[j++];\n      if (!fn) return nextEnter();\n      fn(prev, nextExit);\n    }\n\n    function nextEnter() {\n      var fn = page.callbacks[i++];\n\n      if (ctx.path !== page.current) {\n        ctx.handled = false;\n        return;\n      }\n      if (!fn) return unhandled(ctx);\n      fn(ctx, nextEnter);\n    }\n\n    if (prev) {\n      nextExit();\n    } else {\n      nextEnter();\n    }\n  };\n\n  /**\n   * Unhandled `ctx`. When it's not the initial\n   * popstate then redirect. If you wish to handle\n   * 404s on your own use `page('*', callback)`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n  function unhandled(ctx) {\n    if (ctx.handled) return;\n    var current;\n\n    if (hashbang) {\n      current = base + location.hash.replace('#!', '');\n    } else {\n      current = location.pathname + location.search;\n    }\n\n    if (current === ctx.canonicalPath) return;\n    page.stop();\n    ctx.handled = false;\n    location.href = ctx.canonicalPath;\n  }\n\n  /**\n   * Register an exit route on `path` with\n   * callback `fn()`, which will be called\n   * on the previous context when a new\n   * page is visited.\n   */\n  page.exit = function(path, fn) {\n    if (typeof path === 'function') {\n      return page.exit('*', path);\n    }\n\n    var route = new Route(path);\n    for (var i = 1; i < arguments.length; ++i) {\n      page.exits.push(route.middleware(arguments[i]));\n    }\n  };\n\n  /**\n   * Remove URL encoding from the given `str`.\n   * Accommodates whitespace in both x-www-form-urlencoded\n   * and regular percent-encoded form.\n   *\n   * @param {string} val - URL component to decode\n   */\n  function decodeURLEncodedURIComponent(val) {\n    if (typeof val !== 'string') { return val; }\n    return decodeURLComponents ? decodeURIComponent(val.replace(/\\+/g, ' ')) : val;\n  }\n\n  /**\n   * Initialize a new \"request\" `Context`\n   * with the given `path` and optional initial `state`.\n   *\n   * @constructor\n   * @param {string} path\n   * @param {Object=} state\n   * @api public\n   */\n\n  function Context(path, state) {\n    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + (hashbang ? '#!' : '') + path;\n    var i = path.indexOf('?');\n\n    this.canonicalPath = path;\n    this.path = path.replace(base, '') || '/';\n    if (hashbang) this.path = this.path.replace('#!', '') || '/';\n\n    this.title = document.title;\n    this.state = state || {};\n    this.state.path = path;\n    this.querystring = ~i ? decodeURLEncodedURIComponent(path.slice(i + 1)) : '';\n    this.pathname = decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);\n    this.params = {};\n\n    // fragment\n    this.hash = '';\n    if (!hashbang) {\n      if (!~this.path.indexOf('#')) return;\n      var parts = this.path.split('#');\n      this.path = parts[0];\n      this.hash = decodeURLEncodedURIComponent(parts[1]) || '';\n      this.querystring = this.querystring.split('#')[0];\n    }\n  }\n\n  /**\n   * Expose `Context`.\n   */\n\n  page.Context = Context;\n\n  /**\n   * Push state.\n   *\n   * @api private\n   */\n\n  Context.prototype.pushState = function() {\n    page.len++;\n    history.pushState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n  };\n\n  /**\n   * Save the context state.\n   *\n   * @api public\n   */\n\n  Context.prototype.save = function() {\n    history.replaceState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n  };\n\n  /**\n   * Initialize `Route` with the given HTTP `path`,\n   * and an array of `callbacks` and `options`.\n   *\n   * Options:\n   *\n   *   - `sensitive`    enable case-sensitive routes\n   *   - `strict`       enable strict matching for trailing slashes\n   *\n   * @constructor\n   * @param {string} path\n   * @param {Object=} options\n   * @api private\n   */\n\n  function Route(path, options) {\n    options = options || {};\n    this.path = (path === '*') ? '(.*)' : path;\n    this.method = 'GET';\n    this.regexp = pathtoRegexp(this.path,\n      this.keys = [],\n      options);\n  }\n\n  /**\n   * Expose `Route`.\n   */\n\n  page.Route = Route;\n\n  /**\n   * Return route middleware with\n   * the given callback `fn()`.\n   *\n   * @param {Function} fn\n   * @return {Function}\n   * @api public\n   */\n\n  Route.prototype.middleware = function(fn) {\n    var self = this;\n    return function(ctx, next) {\n      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);\n      next();\n    };\n  };\n\n  /**\n   * Check if this route matches `path`, if so\n   * populate `params`.\n   *\n   * @param {string} path\n   * @param {Object} params\n   * @return {boolean}\n   * @api private\n   */\n\n  Route.prototype.match = function(path, params) {\n    var keys = this.keys,\n      qsIndex = path.indexOf('?'),\n      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,\n      m = this.regexp.exec(decodeURIComponent(pathname));\n\n    if (!m) return false;\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      var key = keys[i - 1];\n      var val = decodeURLEncodedURIComponent(m[i]);\n      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {\n        params[key.name] = val;\n      }\n    }\n\n    return true;\n  };\n\n\n  /**\n   * Handle \"populate\" events.\n   */\n\n  var onpopstate = (function () {\n    var loaded = false;\n    if ('undefined' === typeof window) {\n      return;\n    }\n    if (document.readyState === 'complete') {\n      loaded = true;\n    } else {\n      window.addEventListener('load', function() {\n        setTimeout(function() {\n          loaded = true;\n        }, 0);\n      });\n    }\n    return function onpopstate(e) {\n      if (!loaded) return;\n      if (e.state) {\n        var path = e.state.path;\n        page.replace(path, e.state);\n      } else {\n        page.show(location.pathname + location.hash, undefined, undefined, false);\n      }\n    };\n  })();\n  /**\n   * Handle \"click\" events.\n   */\n\n  function onclick(e) {\n\n    if (1 !== which(e)) return;\n\n    if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n    if (e.defaultPrevented) return;\n\n\n\n    // ensure link\n    // use shadow dom when available\n    var el = e.path ? e.path[0] : e.target;\n    while (el && 'A' !== el.nodeName) el = el.parentNode;\n    if (!el || 'A' !== el.nodeName) return;\n\n\n\n    // Ignore if tag has\n    // 1. \"download\" attribute\n    // 2. rel=\"external\" attribute\n    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;\n\n    // ensure non-hash for the same path\n    var link = el.getAttribute('href');\n    if (!hashbang && el.pathname === location.pathname && (el.hash || '#' === link)) return;\n\n\n\n    // Check for mailto: in the href\n    if (link && link.indexOf('mailto:') > -1) return;\n\n    // check target\n    if (el.target) return;\n\n    // x-origin\n    if (!sameOrigin(el.href)) return;\n\n\n\n    // rebuild path\n    var path = el.pathname + el.search + (el.hash || '');\n\n    // strip leading \"/[drive letter]:\" on NW.js on Windows\n    if (typeof process !== 'undefined' && path.match(/^\\/[a-zA-Z]:\\//)) {\n      path = path.replace(/^\\/[a-zA-Z]:\\//, '/');\n    }\n\n    // same page\n    var orig = path;\n\n    if (path.indexOf(base) === 0) {\n      path = path.substr(base.length);\n    }\n\n    if (hashbang) path = path.replace('#!', '');\n\n    if (base && orig === path) return;\n\n    e.preventDefault();\n    page.show(orig);\n  }\n\n  /**\n   * Event button.\n   */\n\n  function which(e) {\n    e = e || window.event;\n    return null === e.which ? e.button : e.which;\n  }\n\n  /**\n   * Check if `href` is the same origin.\n   */\n\n  function sameOrigin(href) {\n    var origin = location.protocol + '//' + location.hostname;\n    if (location.port) origin += ':' + location.port;\n    return (href && (0 === href.indexOf(origin)));\n  }\n\n  page.sameOrigin = sameOrigin;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/page/index.js\n// module id = 1\n// module chunks = 0 1","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 2\n// module chunks = 0 1","var isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {String} str\n * @return {Array}\n */\nfunction parse (str) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var suffix = res[6]\n    var asterisk = res[7]\n\n    var repeat = suffix === '+' || suffix === '*'\n    var optional = suffix === '?' || suffix === '*'\n    var delimiter = prefix || '/'\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: escapeGroup(pattern)\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {String}   str\n * @return {Function}\n */\nfunction compile (str) {\n  return tokensToFunction(parse(str))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^' + tokens[i].pattern + '$')\n    }\n  }\n\n  return function (obj) {\n    var path = ''\n    var data = obj || {}\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received \"' + value + '\"')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encodeURIComponent(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = encodeURIComponent(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {String} str\n * @return {String}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {String} group\n * @return {String}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {RegExp} re\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {String}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {RegExp} path\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {Array}  path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {String} path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  var tokens = parse(path)\n  var re = tokensToRegExp(tokens, options)\n\n  // Attach keys back to the regexp.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] !== 'string') {\n      keys.push(tokens[i])\n    }\n  }\n\n  return attachKeys(re, keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {Array}  tokens\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction tokensToRegExp (tokens, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n  var lastToken = tokens[tokens.length - 1]\n  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken)\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = token.pattern\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (prefix) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)'\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(String|RegExp|Array)} path\n * @param  {Array}                 [keys]\n * @param  {Object}                [options]\n * @return {RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || []\n\n  if (!isarray(keys)) {\n    options = keys\n    keys = []\n  } else if (!options) {\n    options = {}\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys, options)\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(path, keys, options)\n  }\n\n  return stringToRegexp(path, keys, options)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/path-to-regexp/index.js\n// module id = 3\n// module chunks = 0 1","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/isarray/index.js\n// module id = 4\n// module chunks = 0 1"],"sourceRoot":""}